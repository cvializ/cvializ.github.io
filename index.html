<!DOCTYPE html>
<html>
<link rel="manifest" href="/manifest.json" />
<meta name='viewport' content='initial-scale=1, viewport-fit=cover' />
<meta name="mobile-web-app-capable" content="yes">
<style>
    html {
        background-color: rgb(80, 194, 255);
        overflow: hidden;
    }

    body {
        position: absolute;
        inset: 0;
        margin: 0;
        overflow: auto;

        vertical-align: middle;
    }

    #tapper {
        position: absolute;
        width: fit-content;
        height: fit-content;
        inset: 0;
        margin: auto;
        border: 0;

        text-align: center;
        font-size: min(5vw, 15vh);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";

        user-select: none;
        -webkit-user-select: none;
        cursor: pointer;
        color: white;
        text-shadow: rgb(40, 67, 130) 4px 3px 1px;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    #refreshCount {
        position: absolute;
        inset: 0 0 auto auto;
        padding: 5px;
    }

    #debugMessage {
        position: absolute;
        inset: auto auto 0 auto;
        padding: 5px;
    }
</style>
<div id="refreshCount">Tap</div>
<div role="button" id="tapper">Tap</div>
<pre id="debugMessage"></pre>
<script>
    window.onerror = (error) => alert(error);
</script>
<script>
    // const createObservableInternals = (initialValue) => {
    //     let value = initialValue;
    //     let subscriptions = [];

    //     function getValue() {
    //         return value;
    //     }

    //     function setValue(newValue) {
    //         value = newValue;
    //         subscriptions.forEach((subscription) => subscription(newValue));
    //     }

    //     function subscribe(subscription) {
    //         subscriptions = [...subscriptions, subscription];

    //         return () => {
    //             unsubscribe(subscription);
    //         };
    //     }

    //     function unsubscribe(subscription) {
    //         subscriptions = subscriptions.filter(
    //             (testedSubscription) => testedSubscription !== subscription,
    //         );
    //     }

    //     return [getValue, setValue, subscribe];
    // }

    // const createObservable = (observer) => {
    //     const [getValue, setValue, subscribe] = createObservableInternals();

    //     const subscribeWrapper = (subscriber) => {
    //         subscribe(subscriber);
    //         observer(setValue, alert);
    //     };

    //     return {
    //         subscribe: subscribeWrapper,
    //     };
    // };

    // const createSubject = () => {
    //     let next;
    //     const { subscribe } = createObservable(internalNext => {
    //         next = internalNext;
    //     });

    //     return {
    //         next,
    //         subscribe,
    //     };
    // };

    // const createBehaviorSubject = (initialValue) => {
    //     let value = initialValue;
    //     const { next, subscribe } = createSubject();

    //     const behaviorSubscribe = (subscription) => {
    //         subscribe(subscription);
    //         subscription(value);
    //     };

    //     return {
    //         next,
    //         value,
    //         subscribe: behaviorSubscribe,
    //     };
    // };

    // const createObservableFromPromise = (promise) => {
    //     const promiseStream$ = createBehaviorSubject();

    //     const { next } = promiseStream$;
    //     const onError = () => { };

    //     promise.then(promiseStream.next, onError);

    //     return promiseStream$;
    // };

    // const from = (iterable) => {
    //     const { subscribe } = createObservable((next) => {
    //         iterable.forEach(next);
    //     });

    //     return {
    //         subscribe: (subscriber) => {
    //             const { subscribe } = createObservable((next) => {
    //                 iterable.forEach(next);
    //             });

    //             subscribe((item) => subscriber(item))
    //         }
    //     }
    // };

    const setValue = (key, value) => window.localStorage.setItem(key, value);
    const getValue = (key) => window.localStorage.getItem(key);

    const REFRESH_COUNT_KEY = 'refreshCount';
    const refreshCountElement = document.getElementById('refreshCount');
    const getRefreshCount = () => parseInt(getValue(REFRESH_COUNT_KEY), 10);
    const setRefreshCount = (count) => setValue(REFRESH_COUNT_KEY, count);
    const setRefreshCountMessage = (message) => refreshCountElement.innerText = message;

    const incrementRefreshCount = () => {
        if (getRefreshCount() === null) {
            setRefreshCount(0);
            return;
        }

        const incremented = getRefreshCount() + 1;
        setRefreshCount(incremented);
    };

    const debugMessage = document.getElementById('debugMessage');
    const setDebugMessage = (message) => debugMessage.innerText = message;
    const getDebugMessage = () => debugMessage.innerText;
    const appendDebugMessage = (message) => {
        setDebugMessage(getDebugMessage() + message);
    }

    const tapElement = document.getElementById('tapper');
    const setMessage = (message) => tapElement.innerText = message;
    const getMessage = () => tapElement.innerText;

    const fetchLocation = () => (
        new Promise((resolve, reject) =>
            navigator.geolocation.getCurrentPosition(resolve, reject, {
                enableHighAccuracy: true,
                maximumAge: 10,
                timeout: 27000,
            })
        )
    );

    const watchPosition = (cb) => {
            const id = window.navigator.geolocation.watchPosition(
                ({
                    timestamp,
                    coords,
                }) => {
                    cb({
                        id,
                        timestamp,
                        accuracy: coords.accuracy,
                        latitude: coords.latitude,
                        longitude: coords.longitude,
                        altitude: coords.altitude,
                        altitudeAccuracy: coords.altitudeAccuracy,
                        heading: coords.heading,
                        speed: coords.speed,
                    }, null);
                },
                (error) => { cb(null, error) },
                {
                    enableHighAccuracy: true,
                    maximumAge: 10,
                    timeout: 27000,
                }
            );
        };
    const clearWatchPosition = (id) => navigator.geolocation.clearWatch(id);

    const createInstance = () => {
        setMessage('Walk');

        incrementRefreshCount();
        setRefreshCountMessage(getRefreshCount());
        const { computeAverage } = createAverager();

        watchPosition((result, error) => {
            if (error) {
                setDebugMessage(error);
                return;
            }
            const { speed } = result;
            const averageSpeed = computeAverage(speed || 0);
            appendDebugMessage(JSON.stringify(result) + '\n');

            const averageSpeedMph = averageSpeed * 2.23694;
            setMessage(averageSpeedMph);
        });

        setMessage('ack');
    }

    const clickPromise = new Promise(resolve => {
        tapElement.addEventListener('click', resolve);
    });

    clickPromise
        .then(() => navigator.permissions.query({ name: 'geolocation' }))
        .then(() => createInstance())
        .catch(e => setMessage(e.message + '\n' + fe.stack));

const createAverager = () => {
    let values = [];
    const MAX_AVERAGE = 5;

    function computeAverage(nextValue) {
        values.unshift(nextValue);
        if (values.length > MAX_AVERAGE) {
            values.pop();
        }

        const average = values.reduce((acc, d) => acc + d) / values.length;
        return Math.round(average);
    }

    return {
        computeAverage,
    };
}
</script>

