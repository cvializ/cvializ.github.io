<!DOCTYPE html>
<html>
<link rel="manifest" href="/manifest.json" />
<meta name='viewport' content='initial-scale=1, viewport-fit=cover' />
<meta name="mobile-web-app-capable" content="yes">
<style>
    html {
        background-color: rgb(80, 194, 255);
        overflow: hidden;
    }

    body {
        position: absolute;
        inset: 0;
        margin: 0;
        overflow: auto;

        vertical-align: middle;
    }

    #tapper {
        position: absolute;
        width: fit-content;
        height: fit-content;
        inset: 0;
        margin: auto;
        border: 0;

        text-align: center;
        font-size: min(5vw, 15vh);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";

        user-select: none;
        -webkit-user-select: none;
        cursor: pointer;
        color: white;
        text-shadow: rgb(40, 67, 130) 4px 3px 1px;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    #refreshCount {
        position: absolute;
        inset: 0 0 auto auto;
        padding: 5px;
    }

    #debugMessage {
        position: absolute;
        inset: auto auto 0 auto;
        padding: 5px;
    }
</style>
<div id="refreshCount">Tap</div>
<div role="button" id="tapper">Tap</div>
<pre id="debugMessage"></pre>
<script>
    window.onerror = (error) => alert(error);
</script>
<script>
    const noop = () => {};

    const createObservable = (subscriber) => {

        const subscribe = (onNext = noop, onError = noop, onComplete = noop) => {
            return subscriber(onNext, onError, onComplete);
        };

        const self$ = {
            subscribe,
            pipe: (...operators) => (
                operators.reduce((
                    observable$,
                    operator
                ) => operator(observable$), self$)
            ),
        };

        return self$;
    };

    const of = (scalar) => {
        return createObservable((next) => {
            next(scalar);
        });
    };

    const pipe = (observable$, operator) => {
        return operator(observable$);
    };

    const tap = (cb) => (source$) => {
        return createObservable((next, error, complete) => {
            source$.subscribe((value) => {
                cb(value);
                next(value);
            }, error, complete);

            return noop;
        });
    };

    const scan = (cb, seed) => source$ => {
        return createObservable((next, error, complete) => {
            let accumulator = seed;

            source$.subscribe((value) => {
                accumulator = cb(accumulator, value);
                next(accumulator);
            }, error, complete);

            return noop;
        });
    };

    const map = (cb) => (source$) => {
        return createObservable((next, error, complete) => {
            source$.subscribe((value) => {
                next(cb(value));
            }, error, complete);

            return noop;
        });
    };

    const filter = (condition) => source$ => {
        return createObservable((next, error, complete) => {
            source$.subscribe((value) => {
                if (condition(value)) {
                    next(value);
                }
            }, error, complete);

            return noop;
        });
    };

    const bufferQueue = (length) => (source$) => {
        return createObservable((next, error, complete) => {
            const buffer = [];

            source$.subscribe((value) => {
                buffer.unshift(value);

                if (buffer.length === 1) {
                    return;
                }

                if (buffer.length > length) {
                    buffer.pop();
                }

                next(buffer);
            }, error, complete);

            return noop;
        });
    }

    const pairwise = () => (source$) => {
        return source$.pipe(bufferQueue(2));
    }

    const pair = () => source$ => {
        return source$.pipe(
            bufferQueue(2),
            filter(buffer => buffer.length === 1),
        )
    };

    const merge = (...sources) => {
        return createObservable((next, error, complete) => {
            sources.forEach(source$ => source$.subscribe((value) => {
                next(value);
            }, error, complete));

            return noop;
        });
    };

    const setValue = (key, value) => window.localStorage.setItem(key, value);
    const getValue = (key) => window.localStorage.getItem(key);

    const REFRESH_COUNT_KEY = 'refreshCount';
    const refreshCountElement = document.getElementById('refreshCount');
    const getRefreshCount = () => parseInt(getValue(REFRESH_COUNT_KEY), 10);
    const setRefreshCount = (count) => setValue(REFRESH_COUNT_KEY, count);
    const setRefreshCountMessage = (message) => refreshCountElement.innerText = message;

    const incrementRefreshCount = () => {
        if (getRefreshCount() === null) {
            setRefreshCount(0);
            return;
        }

        const incremented = getRefreshCount() + 1;
        setRefreshCount(incremented);
    };

    const debugMessage = document.getElementById('debugMessage');
    const setDebugMessage = (message) => debugMessage.innerText = message;
    const getDebugMessage = () => debugMessage.innerText;
    const appendDebugMessage = (message) => {
        setDebugMessage(getDebugMessage() + message + '\n');
    }

    const tapElement = document.getElementById('tapper');
    const setMessage = (message) => tapElement.innerText = message;
    const getMessage = () => tapElement.innerText;

    const watchPosition = () => {
        return createObservable((next, error, complete) => {
            const id = window.navigator.geolocation.watchPosition(
                ({
                    timestamp,
                    coords,
                }) => {
                    next({
                        id,
                        timestamp,
                        accuracy: coords.accuracy,
                        latitude: coords.latitude,
                        longitude: coords.longitude,
                        altitude: coords.altitude,
                        altitudeAccuracy: coords.altitudeAccuracy,
                        heading: coords.heading,
                        speed: coords.speed,
                    });
                },
                (e) => { error(e.message) },
                {
                    enableHighAccuracy: true,
                    maximumAge: 10,
                    timeout: 27000,
                }
            );

            return () => {
                window.navigator.geolocation.clearWatch(id);
            };
        });
    };
    const clearWatchPosition = (id) => navigator.geolocation.clearWatch(id);

    const createInstance = () => {
        setMessage('Walk');

        incrementRefreshCount();
        setRefreshCountMessage(getRefreshCount());
        // const { computeAverage } = createAverager();

        const position$ = watchPosition();
        const distance$ = position$.pipe(
            filter(position => position.speed !== null),
            map((position) => {
                const { speed, timestamp } = position;
                return {
                    speed,
                    timestamp,
                };
            }),
            pairwise(),
            map(([later, earlier]) => {
                const intervalMs = later.timestamp - earlier.timestamp;
                const distance = later.speed * intervalMs / 1000;
                return distance;
            }),
        );
        const sum = (a, b) => a + b;
        const cumulativeDistance$ = distance$.pipe(
            scan(sum, 0)
        );

        const speed$ = position$.pipe(
            map(({ speed }) => speed),
        );

        const average = values => values.reduce((acc, d) => acc + d) / values.length;
        const metersPerSecondToMilesPerHour = speed => speed * 2.23694;

        const speedBuffer$ = position$.pipe(
            map(({ speed }) => speed),
            filter(speed => speed !== null),
            bufferQueue(5),
        );
        const averageSpeed$ = speedBuffer$.pipe(
            map(speeds => average(speeds)),
        );

        const unsubscribe = averageSpeed$.pipe(
            map(metersPerSecondToMilesPerHour),
        ).subscribe((averageSpeedMph) => {
            setMessage(averageSpeedMph + 'mph');
        }, error => {
            setDebugMessage(error);
        });

        setMessage('ack');

        const positionMessage$ = position$.pipe(map(({ timestamp }) => {
            return `Got position at ${new Date(timestamp)}`;
        }));

        const distanceMessage$ = cumulativeDistance$.pipe(map((distance) => {
            return `Cumulative Distance: ${distance}`;
        }));

        const speedBufferMessage$ = merge(
            of('cool'),
            speedBuffer$.pipe(
                map(JSON.stringify),
                map((distance) => {
                    return `Speed: ${distance}`;
                }))
            );

        merge(of('ack'), positionMessage$, distanceMessage$, speedBufferMessage$).subscribe(
            (message) => appendDebugMessage(message + '\n'));
    }

    const clickPromise = new Promise(resolve => {
        tapElement.addEventListener('click', resolve);
    });

    clickPromise
        .then(() => navigator.permissions.query({ name: 'geolocation' }))
        .then(() => createInstance())
        .catch(e => setMessage(e.message + '\n' + e.stack));
</script>

