<!DOCTYPE html>
<html>
<link rel="manifest" href="/manifest.json" />
<meta name='viewport' content='initial-scale=1, viewport-fit=cover' />
<meta name="mobile-web-app-capable" content="yes">
<style>
    html {
        background-color: rgb(80, 194, 255);
        overflow: hidden;
    }

    body {
        position: absolute;
        inset: 0;
        margin: 0;
        overflow: auto;

        vertical-align: middle;
    }

    #move {
        position: absolute;
        width: fit-content;
        height: fit-content;
        inset: 0;
        margin: auto;
        border: 0;

        text-align: center;
        font-size: min(5vw, 15vh);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";

        user-select: none;
        -webkit-user-select: none;
        cursor: pointer;
        color: white;
        text-shadow: rgb(40, 67, 130) 4px 3px 1px;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    }

    #refreshCount {
        position: absolute;
        inset: 0 0 auto auto;
        padding: 5px;
    }

    #debugMessage {
        position: absolute;
        inset: auto auto 0 auto;
        padding: 5px;
    }
</style>
<div id="refreshCount">Tap</div>
<div role="button" id="move">Tap</div>
<pre id="debugMessage"></pre>
<script>
    window.onerror = (error) => alert(error);
</script>
<script>
    const createObservableInternals = (initialValue) => {
        let value = initialValue;
        let subscriptions = [];

        function getValue() {
            return value;
        }

        function setValue(newValue) {
            value = newValue;
            subscriptions.forEach((subscription) => subscription(newValue));
        }

        function subscribe(subscription) {
            subscriptions = [...subscriptions, subscription];

            return () => {
                unsubscribe(subscription);
            };
        }

        function unsubscribe(subscription) {
            subscriptions = subscriptions.filter(
                (testedSubscription) => testedSubscription !== subscription,
            );
        }

        return [getValue, setValue, subscribe];
    }

    const createObservable = (observer) => {
        const [getValue, setValue, subscribe] = createObservableInternals();

        const subscribeWrapper = (subscriber) => {
            subscribe(subscriber);
            observer(setValue, alert);
        };

        return {
            subscribe: subscribeWrapper,
        };
    };

    const createSubject = () => {
        let next;
        const { subscribe } = createObservable(internalNext => {
            next = internalNext;
        });

        return {
            next,
            subscribe,
        };
    };

    const createBehaviorSubject = (initialValue) => {
        let value = initialValue;
        const { next, subscribe } = createSubject();

        const behaviorSubscribe = (subscription) => {
            subscribe(subscription);
            subscription(value);
        };

        return {
            next,
            value,
            subscribe: behaviorSubscribe,
        };
    };

    const createObservableFromPromise = (promise) => {
        const promiseStream$ = createBehaviorSubject();

        const { next } = promiseStream$;
        const onError = () => { };

        promise.then(promiseStream.next, onError);

        return promiseStream$;
    };

    const from = (iterable) => {
        const { subscribe } = createObservable((next) => {
            iterable.forEach(next);
        });

        return {
            subscribe: (subscriber) => {
                const { subscribe } = createObservable((next) => {
                    iterable.forEach(next);
                });

                subscribe((item) => subscriber(item))
            }
        }
    };

    const setValue = (key, value) => window.localStorage.setItem(key, value);
    const getValue = (key) => window.localStorage.getItem(key);

    const REFRESH_COUNT_KEY = 'refreshCount';
    const refreshCountElement = document.getElementById('refreshCount');
    const getRefreshCount = () => parseInt(getValue(REFRESH_COUNT_KEY), 10);
    const setRefreshCount = (count) => setValue(REFRESH_COUNT_KEY, count);
    const setRefreshCountMessage = (message) => refreshCountElement.innerText = message;

    const incrementRefreshCount = () => {
        if (getRefreshCount() === null) {
            setRefreshCount(0);
            return;
        }

        const incremented = getRefreshCount() + 1;
        setRefreshCount(incremented);
    };

    const debugMessage = document.getElementById('debugMessage');
    const setDebugMessage = (message) => debugMessage.innerText = message;
    const getDebugMessage = () => debugMessage.innerText;
    const appendDebugMessage = (message) => {
        setDebugMessage(getDebugMessage() + message);
    }

    const moveElement = document.getElementById('move');
    const setMessage = (message) => moveElement.innerText = message;
    const getMessage = () => moveElement.innerText;

    const fetchLocation = () => (
        new Promise((resolve, reject) =>
            navigator.geolocation.getCurrentPosition(resolve, reject, {
                enableHighAccuracy: true,
                maximumAge: 10,
                timeout: 27000,
            })
        )
    );

    const watchPosition = () => createObservable((resolve, reject) => {
            const id = navigator.geolocation.watchPosition(
                ({
                    timestamp,
                    coords,
                }) => {
                    resolve({
                        id,
                        timestamp,
                        accuracy: coords.accuracy,
                        latitude: coords.latitude,
                        longitude: coords.longitude,
                        altitude: coords.altitude,
                        altitudeAccuracy: coords.altitudeAccuracy,
                        heading: coords.heading,
                        speed: coords.speed,
                    })
                },
                (error) => reject(error),
                {
                    enableHighAccuracy: true,
                    maximumAge: 10,
                    timeout: 27000,
                }
            );
        });
    const clearWatchPosition = (id) => navigator.geolocation.clearWatch(id);

    const createInstance = () => {
        incrementRefreshCount();
        setRefreshCountMessage(getRefreshCount());

        watchPosition().subscribe(({ id, ...rest }) => {
            appendDebugMessage(JSON.stringify(rest) + '\n');
        });

        setMessage('ack');
    }

    const clickPromise = new Promise(resolve => {
        moveElement.addEventListener('click', resolve);
    });

    clickPromise
        .then(() => navigator.permissions.query({ name: 'geolocation' }))
        .then(() => createInstance())
        .catch(e => setMessage(e.message + '\n' + fe.stack));

// const createInstance = () => {
//     var lastTimestamp;
//     var speedX = 0, speedY = 0, speedZ = 0;
//     window.addEventListener('devicemotion', function (event) {
//         console.log(event);
//         const { x, y, z } = event.accelerationIncludingGravity;

//         const currentMessage = getMessage();

//         if (Math.abs(x) > 9) {
//             setMessage('X is Up');
//             return;
//         }

//         if (Math.abs(y) > 9) {
//             setMessage('Y is Up');
//             return;
//         }

//         if (Math.abs(z) > 9) {
//             setMessage('Z is Up');
//         }
//     }, false);
// };
</script>

